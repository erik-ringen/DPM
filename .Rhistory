labs(title="Model 1") + theme(plot.title = element_text(size=10)) +
scale_y_discrete(labels=c("b_muFemales_Intercept" = "Female intercept", "b_muMales_Intercept" = "Male intercept", "sd_Genus_species__muFemales_Intercept" = "Female Phylo SD", "sd_Genus_species__muMales_Intercept" = "Male Phylo SD"), expand = expansion(mult = c(0.1, 0))) +  theme(axis.text=element_text(size=5))
mcmc_areas(post_m1_looped, pars = c("b_muFemales_Intercept", "b_muMales_Intercept", "sd_Genus_species__muFemales_Intercept", "sd_Genus_species__muMales_Intercept"), point_est="median", prob = 0.90, prob_outer = 0.99, area_method = "scaled height", border_size = 1.2) +
labs(title="Model 1") + theme(plot.title = element_text(size=10)) +
scale_y_discrete(labels=c("b_muFemales_Intercept" = "Female intercept", "b_muMales_Intercept" = "Male intercept", "sd_Genus_species__muFemales_Intercept" = "Female Phylo SD", "sd_Genus_species__muMales_Intercept" = "Male Phylo SD"), expand = expansion(mult = c(0.05, 0))) +  theme(axis.text=element_text(size=5))
log(4.9)
95000/13
setwd("~/GitHub/DPM")
library(cmdstanr)
library(phytools)
library(phangorn)
library(posterior)
source("chop_tree.R")
## Simulate a random phylogenetic tree (pure birth)
N_tips <- 25
# Vectors to hold rank statistics for A matrix
A_1_2_rank <- c()
A_2_1_rank <- c()
# Compile stan models
sim_mod <- cmdstan_model(stan_file="DPM_sim.stan")
set_cmdstan_path()
?set_cmdstan_path
install_cmdstan()
install_cmdstan(dir = "C:\\Program Files\\R\\R-4.2.0\\library")
check_cmdstan_toolchain(fix = TRUE)
install_cmdstan(dir = "C:\\Program Files\\R\\R-4.2.0\\library")
# Compile stan models
sim_mod <- cmdstan_model(stan_file="DPM_sim.stan")
set_cmdstan_path()
rebuild_cmdstan()
?set_cmdstan_path
install_cmdstan()
install_cmdstan(dir = "C:\\Program Files\\R\\R-4.2.0\\library")
install_cmdstan(dir = "C:\\Program Files\\R\\R-4.2.0\\library", overwrite=TRUE)
set_cmdstan_path(path = "C:\\Program Files\\R\\R-4.2.0\\library\\cmdstan-2.29.2")
set_cmdstan_path(path = "C:\\Program Files\\R\\R-4.2.0\\library\\cmdstan-2.29.2")
library(cmdstanr)
# Compile stan models
sim_mod <- cmdstan_model(stan_file="DPM_sim.stan")
setwd("~/GitHub/DPM")
# Compile stan models
sim_mod <- cmdstan_model(stan_file="DPM_sim.stan")
pwd()
getwd()
fit_mod <- cmdstan_model(stan_file="DPM_fit.stan")
cmdstanr_example(example="logistic")
# Compile stan models
sim_mod <- cmdstan_model(stan_file="DPM_sim.stan")
?cmdstan_model
source("chop_tree.R")
# Compile stan models
sim_mod <- cmdstan_model("DPM_sim.stan")
set_cmdstan_path()
library(cmdstanr)
# Compile stan models
sim_mod <- cmdstan_model("DPM_sim.stan")
set_cmdstan_path()
set_cmdstan_path(path = "C:\\Program Files\\R\\R-4.2.0\\library\\cmdstan")
# Compile stan models
sim_mod <- cmdstan_model("DPM_sim.stan")
library(rethinking)
library(phytools)
library(phangorn)
source("chop_tree.R")
## Simulate a random phylogenetic tree (pure birth)
N_tips <- 25
# Vectors to hold rank statistics for A matrix
A_1_2_rank <- c()
A_2_1_rank <- c()
# Compile stan models
sim_mod <- stan_model(file="DPM_sim.stan")
fit_mod <- stan_model(file="DPM_fit.stan")
###################################################
#### Loop over simulations ########################
N_sims <- 250
for ( s in 1:N_sims ) {
tree <- pbtree(n = N_tips)
tree_data <- chop_tree(tree)
#  Specify number of traits
J <- 2
tree_data$J <- 2
tree_data$resp_type <- c(1,1)
# Draw samples from generative model
sim <- sampling(sim_mod, data=tree_data, iter=1, chains=1, algorithm="Fixed_param")
post_sim <- extract.samples(sim)
A_sim <- post_sim$A[1,,]
# Add simulated outcome data
tree_data$X <- post_sim$X[1,,]
n_warmup <- 100
n_samps <- 250
n_chains <- 8
fit <- sampling(fit_mod, data=tree_data, warmup=n_warmup, iter=n_samps, chains=8, cores=8, control=list(adapt_delta=0.9), init="0")
post_fit <- extract.samples(fit)
A_fit <- post_fit$A
A_1_2_rank[s] <- rank( c(A_sim[1,2], A_fit[,1,2]) )[1]
A_2_1_rank[s] <- rank( c(A_sim[2,1], A_fit[,2,1]) )[1]
} # end loop over simulations
# Save results
write.csv(data.frame(A_1_2_rank, A_2_1_rank), file="SBC_ranks.csv")
library(rethinking)
library(phytools)
library(phangorn)
source("chop_tree.R")
## Simulate a random phylogenetic tree (pure birth)
N_tips <- 25
# Vectors to hold rank statistics for A matrix
A_1_2_rank <- c()
A_2_1_rank <- c()
# Compile stan models
sim_mod <- stan_model(file="DPM_sim.stan")
fit_mod <- stan_model(file="DPM_fit.stan")
###################################################
#### Loop over simulations ########################
N_sims <- 1000
getwd()
# Compile stan models
sim_mod <- stan_model(file="DPM_sim.stan")
fit_mod <- stan_model(file="DPM_fit.stan")
# Save results
str(sim_mod)
library(help = "rstan")
library(rethinking)
library(phytools)
library(phangorn)
source("chop_tree.R")
## Simulate a random phylogenetic tree (pure birth)
N_tips <- 25
# Vectors to hold rank statistics for A matrix
A_1_2_rank <- c()
A_2_1_rank <- c()
sim_mod<- readRDS("sim_mod.rds")
fit_mod <- stan_model(file="DPM_fit.stan")
N_sims <- 1000
for ( s in 1:N_sims ) {
tree <- pbtree(n = N_tips)
tree_data <- chop_tree(tree)
#  Specify number of traits
J <- 2
tree_data$J <- 2
tree_data$resp_type <- c(1,1)
# Draw samples from generative model
sim <- sampling(sim_mod, data=tree_data, iter=1, chains=1, algorithm="Fixed_param")
post_sim <- extract.samples(sim)
A_sim <- post_sim$A[1,,]
# Add simulated outcome data
tree_data$X <- post_sim$X[1,,]
n_warmup <- 100
n_samps <- 350
n_chains <- 8
fit <- sampling(fit_mod, data=tree_data, warmup=n_warmup, iter=n_samps, chains=8, cores=8, control=list(adapt_delta=0.9), init=0.1)
post_fit <- extract.samples(fit)
A_fit <- post_fit$A
A_1_2_rank[s] <- rank( c(A_sim[1,2], A_fit[,1,2]) )[1]
A_2_1_rank[s] <- rank( c(A_sim[2,1], A_fit[,2,1]) )[1]
} # end loop over simulations
# Save results
write.csv(data.frame(A_1_2_rank, A_2_1_rank), file="SBC_ranks.csv")
library(rethinking)
library(phytools)
library(phangorn)
source("chop_tree.R")
## Simulate a random phylogenetic tree (pure birth)
N_tips <- 25
# Vectors to hold rank statistics for A matrix
A_1_2_rank <- c()
A_2_1_rank <- c()
# Compile stan models
sim_mod <- stan_model(file="DPM_sim.stan")
# Compile stan models
sim_mod <- stan_model(file="DPM_sim.stan")
# Compile stan models
sim_mod <- stan_model(file="DPM_sim.stan")
fit_mod <- stan_model(file="DPM_fit.stan")
fit_mod <- stan_model(file="DPM_fit.stan")
# Compile stan models
sim_mod <- stan_model(file="DPM_sim.stan")
?stan_model
# Compile stan models
sim_mod <- stan_model(file="DPM_sim.stan")
simmodcode = "functions {
matrix kronecker_prod(matrix A, matrix B) { // returns the Kronecker Product
matrix[rows(A) * rows(B), cols(A) * cols(B)] C;
int m;
int n;
int p;
int q;
m = rows(A);
n = cols(A);
p = rows(B);
q = cols(B);
for (i in 1:m)
for (j in 1:n)
for (k in 1:p)
for (l in 1:q)
C[p*(i-1)+k,q*(j-1)+l] = A[i,j]*B[k,l];
return C;
}
matrix A_dt(matrix A, real t) {  // expected auto and cross effects over a discrete time t
return( matrix_exp(A * t) );
}
matrix A_sharp(matrix A) {
matrix[rows(A) * rows(A), cols(A) * cols(A)] A_temp;
matrix[rows(A),cols(A)] I; // identity matrix
I = diag_matrix(rep_vector(1,rows(A)));
A_temp = kronecker_prod(A,I) + kronecker_prod(I,A);
return(A_temp);
}
matrix cov_drift(matrix A, matrix Q, real ts) {
matrix[rows(A) * rows(A), cols(A) * cols(A)] A_sharp_temp;
matrix[rows(A) * rows(A), cols(A) * cols(A)] I; // identity matrix
vector[rows(Q)*cols(Q)] row_Q;
vector[rows(A)*cols(A)] irow_vec;
matrix[rows(A),cols(A)] irow_mat;
I = diag_matrix(rep_vector(1,rows(A_sharp_temp)));
A_sharp_temp = A_sharp(A);
// row operation takes elements of a matrix rowwise and puts them into a column vector
for (i in 1:rows(Q))
for (j in 1:cols(Q)) {
row_Q[i + (j-1)*rows(Q)] = Q[j,i];
}
irow_vec = inverse(A_sharp_temp) * (matrix_exp(A_sharp_temp * ts) - I) * row_Q;
// irow takes elements of a column vector and puts them in a matrix rowwise
{
int row_size = rows(A);
int row_ticker = 1;
int col_ticker = 0;
for (i in 1:num_elements(irow_vec)) {
col_ticker += 1;
if (col_ticker > row_size) {
row_ticker += 1;
col_ticker = 1;
}
irow_mat[row_ticker,col_ticker] = irow_vec[i];
}
}
return(irow_mat);
}
real normal_lub_rng(real mu, real sigma, real lb, real ub) {
real p_lb = normal_cdf(lb, mu, sigma);
real p_ub = normal_cdf(ub, mu, sigma);
real u = uniform_rng(p_lb, p_ub);
real y = mu + sigma * inv_Phi(u);
return y;
}
} // end of functions block
data{
int N_tips; // number of tips
int J; // number of response traits
array[J] int resp_type; // type of trait (1 = gaussian, 2 = binomial)
int N_seg; // total number of segments in the tree
array[N_seg] int node_seq; // index of tree nodes
array[N_seg] int parent; // index of the parent node of each descendent
vector[N_seg] ts; // time since parent
vector[N_seg] tip; // indicator of whether a given segment ends in a tip
}
generated quantities{
vector[J] A_diag;
vector[J*J - J] A_offdiag;
vector[J] Q_diag;
vector[J] b;
vector[J] eta_anc;
matrix[N_seg - 1, J] z_drift;
matrix[N_seg,J] eta;
matrix[J,J] Q; // "drift" matrix
matrix[J,J] I; // identity matrix
matrix[J,J] A;  // "selection" matrix
matrix[N_seg,J] drift_tips; // terminal drift parameters, saved here to use in likelihood for Gaussian outcomes
matrix[N_seg,J] sigma_tips; // terminal drift parameters, saved here to use in likelihood for Gaussian outcomes
array[N_tips,J] real X;
vector[J] Q_offdiag = rep_vector(0.0, J);
for (j in 1:J) {
A_diag[j] = normal_lub_rng(0,1,negative_infinity(), 0.0);
A_offdiag[j] = normal_rng(0,1);
Q_diag[j] = normal_lub_rng(0,1,0,positive_infinity());
b[j] = normal_rng(0,1);
eta_anc[j] = normal_rng(0,1);
for (i in 1:(N_seg - 1)) z_drift[i,j] = normal_rng(0,1);
}
// Fill A matrix //////////
{
int ticker = 1;
// fill upper tri of matrix
for (i in 1:(J-1))
for (j in (i+1):J) {
A[i,j] = A_offdiag[ticker];
ticker += 1;
}
// fill lower tri of matrix
for (i in 1:(J-1))
for (j in (i+1):J) {
A[j,i] = A_offdiag[ticker];
ticker += 1;
}
// fill diag of matrix
for (j in 1:J) A[j,j] = A_diag[j];
}
// Fill Q matrix /////
{
int ticker = 1;
for (i in 1:(J-1))
for (j in (i+1):J) {
Q[i,j] = Q_offdiag[ticker];
Q[j,i] = Q_offdiag[ticker]; // symmetry of covariance
ticker += 1;
}
for (j in 1:J) Q[j,j] = Q_diag[j];
}
// identity matrix
I = diag_matrix(rep_vector(1,J));
// setting ancestral states, and placeholders
for (j in 1:J) {
eta[node_seq[1],j] = eta_anc[j]; // ancestral state
drift_tips[node_seq[1],j] = -99; //
sigma_tips[node_seq[1],j] = -99; //
}
for (i in 2:N_seg) {
matrix[J,J] A_delta; // amount of deterministic change ("selection")
matrix[J,J] VCV; // variance-covariance matrix of stochastic change ("drift")
vector[J] drift_seg; // accumulated drift over the segment
A_delta = A_dt(A, ts[i]);
VCV = cov_drift(A, Q, ts[i]);
// No drift on the interaction, bc its simply a product of RI and TPC
drift_seg = cholesky_decompose(VCV) * to_vector( z_drift[i-1,] );
// if not a tip, add the drift parameter
if (tip[i] == 0) {
eta[node_seq[i],] = to_row_vector(
A_delta * to_vector(eta[parent[i],]) + (inverse(A) * (A_delta - I) * b) + drift_seg
);
drift_tips[node_seq[i],] = to_row_vector(rep_vector(-99, J));
sigma_tips[node_seq[i],] = to_row_vector(rep_vector(-99, J));
}
// if is a tip, omit, we'll deal with it in the model block
else {
eta[node_seq[i],] = to_row_vector(
A_delta * to_vector(eta[parent[i],]) + (inverse(A) * (A_delta - I) * b)
);
drift_tips[node_seq[i],] = to_row_vector(drift_seg);
sigma_tips[node_seq[i],] = to_row_vector(sqrt(diagonal(VCV)));
}
}
## Simulate observations
for (j in 1:J) {
if (resp_type[j] == 1) {
for (i in 1:N_tips) X[i,j] = eta[i,j] + normal_rng( 0, sigma_tips[i,j] );
}
if (resp_type[j] == 2) {
for (i in 1:N_tips) X[i,j] = bernoulli_logit_rng( eta[i,j] + drift_tips[i,j] );
}
}
}
"
simmodcode = '
functions {
matrix kronecker_prod(matrix A, matrix B) { // returns the Kronecker Product
matrix[rows(A) * rows(B), cols(A) * cols(B)] C;
int m;
int n;
int p;
int q;
m = rows(A);
n = cols(A);
p = rows(B);
q = cols(B);
for (i in 1:m)
for (j in 1:n)
for (k in 1:p)
for (l in 1:q)
C[p*(i-1)+k,q*(j-1)+l] = A[i,j]*B[k,l];
return C;
}
matrix A_dt(matrix A, real t) {  // expected auto and cross effects over a discrete time t
return( matrix_exp(A * t) );
}
matrix A_sharp(matrix A) {
matrix[rows(A) * rows(A), cols(A) * cols(A)] A_temp;
matrix[rows(A),cols(A)] I; // identity matrix
I = diag_matrix(rep_vector(1,rows(A)));
A_temp = kronecker_prod(A,I) + kronecker_prod(I,A);
return(A_temp);
}
matrix cov_drift(matrix A, matrix Q, real ts) {
matrix[rows(A) * rows(A), cols(A) * cols(A)] A_sharp_temp;
matrix[rows(A) * rows(A), cols(A) * cols(A)] I; // identity matrix
vector[rows(Q)*cols(Q)] row_Q;
vector[rows(A)*cols(A)] irow_vec;
matrix[rows(A),cols(A)] irow_mat;
I = diag_matrix(rep_vector(1,rows(A_sharp_temp)));
A_sharp_temp = A_sharp(A);
// row operation takes elements of a matrix rowwise and puts them into a column vector
for (i in 1:rows(Q))
for (j in 1:cols(Q)) {
row_Q[i + (j-1)*rows(Q)] = Q[j,i];
}
irow_vec = inverse(A_sharp_temp) * (matrix_exp(A_sharp_temp * ts) - I) * row_Q;
// irow takes elements of a column vector and puts them in a matrix rowwise
{
int row_size = rows(A);
int row_ticker = 1;
int col_ticker = 0;
for (i in 1:num_elements(irow_vec)) {
col_ticker += 1;
if (col_ticker > row_size) {
row_ticker += 1;
col_ticker = 1;
}
irow_mat[row_ticker,col_ticker] = irow_vec[i];
}
}
return(irow_mat);
}
real normal_lub_rng(real mu, real sigma, real lb, real ub) {
real p_lb = normal_cdf(lb, mu, sigma);
real p_ub = normal_cdf(ub, mu, sigma);
real u = uniform_rng(p_lb, p_ub);
real y = mu + sigma * inv_Phi(u);
return y;
}
} // end of functions block
data{
int N_tips; // number of tips
int J; // number of response traits
array[J] int resp_type; // type of trait (1 = gaussian, 2 = binomial)
int N_seg; // total number of segments in the tree
array[N_seg] int node_seq; // index of tree nodes
array[N_seg] int parent; // index of the parent node of each descendent
vector[N_seg] ts; // time since parent
vector[N_seg] tip; // indicator of whether a given segment ends in a tip
}
generated quantities{
vector[J] A_diag;
vector[J*J - J] A_offdiag;
vector[J] Q_diag;
vector[J] b;
vector[J] eta_anc;
matrix[N_seg - 1, J] z_drift;
matrix[N_seg,J] eta;
matrix[J,J] Q; // "drift" matrix
matrix[J,J] I; // identity matrix
matrix[J,J] A;  // "selection" matrix
matrix[N_seg,J] drift_tips; // terminal drift parameters, saved here to use in likelihood for Gaussian outcomes
matrix[N_seg,J] sigma_tips; // terminal drift parameters, saved here to use in likelihood for Gaussian outcomes
array[N_tips,J] real X;
vector[J] Q_offdiag = rep_vector(0.0, J);
for (j in 1:J) {
A_diag[j] = normal_lub_rng(0,1,negative_infinity(), 0.0);
A_offdiag[j] = normal_rng(0,1);
Q_diag[j] = normal_lub_rng(0,1,0,positive_infinity());
b[j] = normal_rng(0,1);
eta_anc[j] = normal_rng(0,1);
for (i in 1:(N_seg - 1)) z_drift[i,j] = normal_rng(0,1);
}
// Fill A matrix //////////
{
int ticker = 1;
// fill upper tri of matrix
for (i in 1:(J-1))
for (j in (i+1):J) {
A[i,j] = A_offdiag[ticker];
ticker += 1;
}
// fill lower tri of matrix
for (i in 1:(J-1))
for (j in (i+1):J) {
A[j,i] = A_offdiag[ticker];
ticker += 1;
}
// fill diag of matrix
for (j in 1:J) A[j,j] = A_diag[j];
}
// Fill Q matrix /////
{
int ticker = 1;
for (i in 1:(J-1))
for (j in (i+1):J) {
Q[i,j] = Q_offdiag[ticker];
Q[j,i] = Q_offdiag[ticker]; // symmetry of covariance
ticker += 1;
}
for (j in 1:J) Q[j,j] = Q_diag[j];
}
// identity matrix
I = diag_matrix(rep_vector(1,J));
// setting ancestral states, and placeholders
for (j in 1:J) {
eta[node_seq[1],j] = eta_anc[j]; // ancestral state
drift_tips[node_seq[1],j] = -99; //
sigma_tips[node_seq[1],j] = -99; //
}
for (i in 2:N_seg) {
matrix[J,J] A_delta; // amount of deterministic change ("selection")
matrix[J,J] VCV; // variance-covariance matrix of stochastic change ("drift")
vector[J] drift_seg; // accumulated drift over the segment
A_delta = A_dt(A, ts[i]);
VCV = cov_drift(A, Q, ts[i]);
// No drift on the interaction, bc its simply a product of RI and TPC
drift_seg = cholesky_decompose(VCV) * to_vector( z_drift[i-1,] );
// if not a tip, add the drift parameter
if (tip[i] == 0) {
eta[node_seq[i],] = to_row_vector(
A_delta * to_vector(eta[parent[i],]) + (inverse(A) * (A_delta - I) * b) + drift_seg
);
drift_tips[node_seq[i],] = to_row_vector(rep_vector(-99, J));
sigma_tips[node_seq[i],] = to_row_vector(rep_vector(-99, J));
}
// if is a tip, omit, we'll deal with it in the model block
?stan
# Compile stan models
sim_mod <- stan(file="DPM_sim.stan")
# Compile stan models
sim_mod <- rstan::stan(file="DPM_sim.stan")
# Compile stan models
sim_mod <- stan_model(file="DPM_sim.stan")
